#!/usr/bin/python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import with_statement

import os
import sys

from qpid_messaging import *
from qpid_messaging import __file__ as messaging_module_file

home = os.path.normpath("@quiver_home@")
sys.path.insert(0, os.path.join(home, "python"))

from plano import *
from quiver.common import now

link_options = "{link: {durable: False, reliability: at-least-once}}"

class Client(object):
    def __init__(self):
        self.operation = None
        self.id_ = None
        self.host = None
        self.port = None
        self.path = None
        self.seconds = None
        self.messages = None
        self.body_size = None
        self.credit_window = None
        self.transaction_size = None
        self.durable = False

        self.body = None

        self.start_time = None
        self.sent = 0
        self.received = 0

    def run(self):
        self.body = b"x" * self.body_size

        domain = "{}:{}".format(self.host, self.port)
        conn = Connection(domain,
                          protocol=b"amqp1.0",
                          container_id=self.id_,
                          sasl_mechanisms=b"ANONYMOUS")

        conn.open()

        self.start_time = now()

        try:
            transactional = self.transaction_size > 0
            session = conn.session(transactional=transactional)

            if self.operation == "send":
                self.send_messages(session)
            elif self.operation == "receive":
                self.receive_messages(session)
            else:
                raise Exception()

            if transactional:
                session.commit()
        finally:
            conn.close()

    def send_messages(self, session):
        # XXX
        # NotImplementedError: Wrong number or type of arguments for overloaded function 'Session__sender'.
        #   Possible C/C++ prototypes are:
        #     qpid::messaging::Session::createSender(qpid::messaging::Address const &)
        #     qpid::messaging::Session::createSender(std::string const &)
        #address = "{}; {}".format(self.path, link_options)
        #sender = session.sender(address)
        sender = session.sender(self.path)
        sender.capacity = self.credit_window

        while self.sent < self.messages:
            if self.sent % 1000 == 0 and now() - self.start_time >= self.seconds * 1000:
                break

            id_ = str(self.sent + 1)
            stime = now()
            record = "{},{}\n".format(id_, stime)

            message = Message(self.body)
            message.id = id_
            message.properties[b"SendTime"] = stime

            if self.durable:
                message.durable = True

            sender.send(message)

            sys.stdout.write(record)

            self.sent +=1

            if self.transaction_size > 0 and (self.sent % self.transaction_size) == 0:
                session.commit()

    def receive_messages(self, session):
        # XXX See above
        #address = "{}; {}".format(self.path, link_options)
        #receiver = session.receiver(address)
        receiver = session.receiver(self.path)
        receiver.capacity = self.credit_window

        while self.received < self.messages:
            if self.sent % 1000 == 0 and now() - self.start_time >= self.seconds * 1000:
                break

            if receiver.available() == 0:
                continue

            message = receiver.get()
            session.acknowledge()

            stime = message.properties["SendTime"]
            rtime = now()
            record = "{},{},{}\n".format(message.id, stime, rtime)

            sys.stdout.write(record)

            self.received +=1

            if self.transaction_size > 0 and (self.received % self.transaction_size) == 0:
                session.commit()

def main():
    set_message_threshold("warn")

    if len(ARGS) == 1:
        print("Qpid Messaging Python XXX")
        print(messaging_module_file)
        print("Python {}".format(" ".join(sys.version.split())))

        exit()

    if ARGS[1] != "client":
        exit("This impl supports client mode only")

    if ARGS[2] != "active":
        exit("This impl supports active mode only")

    client = Client()
    client.operation = ARGS[3]
    client.id_ = ARGS[4]
    client.host = ARGS[5]
    client.port = ARGS[6]
    client.path = ARGS[7]
    client.seconds = 10 # XXX
    client.messages = int(ARGS[8])
    client.body_size = int(ARGS[9])
    client.credit_window = int(ARGS[10])
    client.transaction_size = int(ARGS[11])

    flags = ARGS[12].split(",")

    if "durable" in flags:
        client.durable = True

    client.run()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
